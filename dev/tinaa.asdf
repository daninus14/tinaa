;;; -*- Mode: Lisp; package: CL-USER; Syntax: Common-lisp; Base: 10 -*-#|$Id: tinaa.asdf,v 1.2 2004/06/03 17:30:32 gwking Exp $Copyright 199?-2002 Experimental Knowledge Systems Lab, University of Massachusetts AmherstProfessor Paul Cohen, DirectorAuthor: Westy, et. al.  (most recent working over by Gary King, Brent Heeringa, Louis Theran)|#(defpackage :tinaa-system (:use #:cl #:asdf))(in-package :tinaa-system)(eval-when (:compile-toplevel :load-toplevel :execute)  (defun build-eksl-physical-translation (translation)    (etypecase translation       ((or symbol string)       `(relative-namestring-with-base-dir         translated-base-pathname         ,(string translation)         :wild-inferiors) )      (cons        (cond ((eq (first translation) :BINARY-DIRECTORY)              `(relative-namestring-with-base-dir                translated-base-pathname                 ,@(let ((name (third translation)))                    (if (null name)                      nil                      (list (string name))))                (bin-directory-name "BIN" ',(second translation))                :wild-inferiors))             ((eq (first translation) :EVAL)              `(relative-namestring-with-base-dir                translated-base-pathname                 ,(second translation)                :wild-inferiors))             (t              `(relative-namestring-with-base-dir                translated-base-pathname                ,@translation                :wild-inferiors))))))    (defmacro eksl-define-logical-pathname-translations ((name &optional base-pathname) &body definitions)    ;#.+eksl-define-logical-pathname-translations-documentation+    (let ((logical-name (string name)))      (flet ((lstring (x) 	       (string-downcase (string x))))        `(let ((translated-base-pathname 	        ,(when base-pathname 		   `(translate-logical-pathname ,base-pathname))))	   (setf (eksl-logical-pathname-translations ,logical-name)	         (list 	          ,@(mapcar 	             #'(lambda (def)		         (cond                           ; FRED -> ("FRED;**;*.*.*" <BASE>+"FRED")		          ((atom def)		           `(list ,(concatenate 'string (lstring def) ";**;*.*.*")			          ,(build-eksl-physical-translation def)))                          ; (FRED) -> ("FRED;**;*.*.*" <BASE>)		          ((null (cdr def))		           `(list ,(concatenate 'string (lstring (first def)) ";**;*.*.*")			          (relative-namestring-with-base-dir 			           translated-base-pathname			           :wild-inferiors)))		                                    ;;; GWK Added 20010618                          ; (:absolute "sam") -> ("FRED;**;*.*.*" "sam") 		          ((and (symbolp (first def))			        (consp (second def))			        (eq (first (second def)) :absolute))		           `(list ,(concatenate 'string (lstring (first def)) ";**;*.*.*")			          ,(second (second def))))		                                    ; (FRED "sam") -> ("FRED;**;*.*.*" <BASE>+"sam")		          ((symbolp (first def))		           `(list ,(concatenate 'string (lstring (first def)) ";**;*.*.*")			          ,(build-eksl-physical-translation 			            (if (consp (second def))                                      (second def)				      (rest def)))))                          ; ** SHOULD ALSO HANDLE **                          ; (FRED;JOE "sam") -> ("FRED;JOE;**;*.*.*" <BASE>+"sam")		          		                                    ; (<something> "sam") -> (<something> <BASE>+"sam")		          (t		           `(list ,(string (first def))			          ,(build-eksl-physical-translation 			            (if (consp (second def))                                      (second def)				      (rest def)))))))	             definitions)	          ;; Add the default translation...	          (list "**;*.*.*" (relative-namestring-with-base-dir translated-base-pathname								      :wild-inferiors))))))))    ;;; ---------------------------------------------------------------------------    (defun relative-namestring-with-base-dir (base-pathname &rest dir-names)    "Starts with the directory of `base-pathname' \(or `load-pathname' ifthis is nil\); it assumes the directory is represented as a list.  It thenmodifies that list by appending things, such as subdirectories, or removing things, to go up the directory tree. Each dir-name argument can be :back, which goes up a subdirectory level, a string, which should be uppercase tospecify common case, or :wild-inferiors.  Returns a directory list."    (namestring (make-pathname                 :directory                  (let ((pn (copy-list (pathname-directory (or base-pathname                                                               (load-pathname))))))                   (dolist (dir dir-names)                     (cond ((eq dir :back)                            (setf pn (nbutlast pn)))                           ((eq dir :wild-inferiors)                            (setf pn (nconc pn (list :wild-inferiors))))                           ;; So far, no platform correctly implements common case, so we have                           ;; to convert strings to lowercase.                           ((stringp dir) (setf pn (nconc pn (list dir))))                           (t                            (error "Not a known kind of dir-name: ~s" dir))))                   pn))))    ;;; ---------------------------------------------------------------------------    (defun load-pathname ()    "Returns a pathname that is useful for merging with filenames to get acomplete pathname for a file in the same directory as the one currently beingloaded.  This function is a more portable version of the Common Lisp variable*load-truename*, since not all vendors implemented that correctly."    (let ((pn   #+allegro (translate-logical-pathname (truename excl:*source-pathname*))                #+MCL (if *load-truename*                         (translate-logical-pathname *load-truename*)                        ;; This makes it work in a fred buffer...                        (translate-logical-pathname ccl:*loading-file-source-file*))                #+Lispworks (translate-logical-pathname *load-truename*)                #-(or allegro MCL Lispworks)                 (translate-logical-pathname *load-truename*)))      (assert (pathnamep pn) (pn)              "load-pathname* did not return a pathname, it returned ~s;this might be because it executed in a context where you're not loading a fileor because the file is in the current working directory.  In any event, this will break the code in generic-load-utils, because it works with the componentsof pathnames." pn)      ;; Deal with the lispworks using an empty pathname for *default-pathname-defaults*      ;; if you are loading from the current working directory.      (values        #-lispworks pn       #+lispworks       (if (null (pathname-directory pn))          (merge-pathnames pn (current-pathname)) pn))))    ;;; ---------------------------------------------------------------------------    (defmacro eksl-logical-pathname-translations (host)    `(logical-pathname-translations ,host))    ;;; ---------------------------------------------------------------------------    (defun eksl-translate-logical-pathname (pathname)    #-(or Allegro OPENMCL)    (translate-logical-pathname pathname)    #+(or Allegro OPENMCL)    (translate-logical-pathname (if (stringp pathname)				  (string-downcase pathname)				  pathname))));;; ---------------------------------------------------------------------------(eksl-define-logical-pathname-translations (tinaa)   (source)   (doc (:back "doc"))   (utils (:back :back "utils" "dev"))   (containers (:back :back "containers" "dev"))   (lift (:back :back "lift" "dev"))   (contrib    (:back "contrib")));;; ---------------------------------------------------------------------------(defsystem "EKSL-UTILITIES-FOR-TINAA"  :pathname "tinaa:utils;"  :components ((:file "bind")               (:file "anaphoric")               (:file "string-utilities")               (:file "file-utilities")               (:file "day-and-time")               (:file "sequence-utilities")               (:file "timeit"))  :depends-on ("EKSL-UTILITIES-SYSTEM-LEVEL-0" "DEFCLASS-STAR"));;; ---------------------------------------------------------------------------(defsystem "TINAA-SYSTEM"  :depends-on (lml)  :version "0.2"  :author "Gary King <gwking@cs.umass.edu>"  :description "TINAA Is Not An Acronym, it's a Lisp documentation system."  :components ((:file "package")               (:file "class-defs" :depends-on ("package"))               (:file "macros" :depends-on ("package"))               (:file "utilities" :depends-on ("package"))               (:file "tinaa" :depends-on ("class-defs"))               (:file "doc-package")               (:file "doc-class")               (:file "doc-variable")               (:file "doc-function")               (:file "doc-symbol")               (:file "doc-eksl-system")               (:file "build-indexes")               (:file "templates"))  :depends-on ("CONTAINERS" "EKSL-UTILITIES-FOR-TINAA"))